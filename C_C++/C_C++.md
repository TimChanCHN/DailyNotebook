# C_C++
## 1 回调函数
1. 定义:回调函数本质就是一个函数指针，其定义方式是：typedef int(*fn)(int, int)，如例子所述，该函数指针fn是一种返回值为in，参数为(int, int)的函数指针。
2. 调用：可以直接调用语句fn(1,2)来达到调用函数指针的作用；
3. 附加说明：在优良的系统框架中，回调函数会把回调函数的定义、初始化、调用都会分开来，因此在查看系统代码的时候，需要把定义、初始化、调用等及部分均查找出来，同 同时，函数参数的传递一般会封装到领带一个函数中，这样子做出来的系统接口会更加简洁，因为这样，应用层无需对回调函数进行赋值操作。

## 2 结构体
1. 结构体会字节对齐，如下例子，因为需要字节对齐，所以该结构体所占内存大小是12个字节：
   ```c
   struct test{
   char a;
   int  b;
   char c;
   };

   struct test A;          // A的内存大小是12个字节
   (struct test*)0;        // 指向该结构体起始地址
   &((struct test*)0)->c;  // 结构体元素c到结构体起始地址的大小
   ```
2. 结构体赋值
   > 数组/字符串的赋值，只能在定义时赋值，不能把一个数组赋值给另外一个数组，而结构体可以。
   ```c
   struct person{
      int a;
      int b;
   };

   struct person test = {1,2}, test1;
   test1 = test;
   ```
3. 结构体类型强转
   > 在对结构体变量进行类型转换的时候，如果转换结果所占的内存比结构体内存小，则转换结构体前面的内存，否则则全部转换，剩余的内存是NULL的(如果前者比后者大，有野指针风险)
   ```c
   struct prt{
      char a;
      int c;
      unsigned long ud;
   };

   struct opp{
      char a;
      int c;
      unsigned long ud;
      char d;
   };

   struct prt test = {'z', 100, 111111};
   opp* ptr = (opp*)&test;                      //结果是等于test，知识prt->d为未知内容
   ```

## 3 链表
   1. 新链表默认表头为空的，只有`next`,`pre`指向空；
2. 建好表头后，需要定义一个链表元素指针`node`指向表头；
3. 对于一个新的链表元素，需要给它赋予一个链表元素空间，赋值之后，令链表元素指针`node`指向该具有实质内容的链表元素；
4. `node`往后指一步：`node = node->next`;
5. 链表元素建成后，`head->next`就是新的链表头。



# 附录
1. 在内核编程时，什么时候定义结构体指针？  
   > 假如需要对结构体赋值时，则定义的是普通结构体变量；假如结构体的初始化由函数完成，则需要定义结构体指针。
   > 因为非指针变量，会自动被分配内存空间，而指针变量则不会，需要利用函数malloc来开辟内存空间。

2. 结构体和类的区别
   1. 类可以有成员函数，并且默认是private，类外元素不可直接访问，而结构体则是public，类外元素可以直接访问。   




