# 固件升级学习
## 1. 概述
1. IAP(In Application Program):在应用编程，指用户程序在运行过程中对Flash的部分区域进行烧写，目的是为了产品发布后可以方便地通过预留的通信口对产品的固件程序进行更新升级。
2. OTA(Over the Air):通过网络升级智能设备。
3. IAP/OTA都是为了对发布后的产品进行固件升级的技术。
4. 与普通固件程序不同，IAP/OTA技术需要使用两个可执行程序，即bootloader+APP
   1. bootloader:先判断更新位状态，决定是否要更新APP；是则擦除APP区域内容之后再把新APP拷贝到要运行的区域，随后要复位状态位；之后则跳转去APP运行区域
   2. APP:APP需要实时接收开发者发送的新程序，并把新程序拷贝到即将运行的区域，同时要置位更新状态位，之后要重启系统

## 2. 具体实现
### 1. 准备工作
1. 内存划分以及工程设置:
    > 此处只是一个示例，根据单片机资源情况、外设情况、应用程序大小情况可以酌情进行空间分配
   1. 分配bootloader、APP1、APP2空间情况
   2. 由于正式运行时SP指针不会指向存储APP2的内存地址，因此在keil工程中，只需要对bootloader和APP1两个应用程序进行运行内存地址以及大小设置
   3. 需要注意单片机片内资源情况，以防生成的可执行程序超过工程设置
2. 由于APP2是升级的程序，即开发者传输的文件，因此APP2的工程需要配置，使其生成.bin文件
3. APP1和APP2功能一样，必须具备的功能有:
   1. 对更新状态位置位(更新状态位的选择--复位后状态位依然会保持，除非软件对其复位)
   2. 会实时接收开发者发送过来的升级固件，并使其存放到APP2(备份区域中)
4. 保护措施:
   1. 若升级失败，该如何处理?
      1. 升级失败的表现是APP2不能正确接收，如果不能正确接收，则放弃固件升级，原程序会继续执行
   2. 传输文件的过程中需要加校验方式，保证传输的bin文件准确无误
      1. 生成的APP2对应的bin文件后面加上CRC校验
      2. 当APP1接收到APP2的bin文件时，先对其进行CRC校验，如果计算出来的结果值和接收到的bin文件最后两个字节(此处是CRC16，校验码也是两个字节，校验码存储在bin文件最后两个字节)一致，认为CRC校验通过
      3. CRC校验通过之后，就把bin文件写入APP2块区
      4. 重启系统，手动或自动升级

#### 2. bootloader
1. 流程
   1. 读取更新状态
   2. 是则使用APP2代替APP1，否则跳去第6点
   3. 将APP2的内容拷贝到APP1
   4. 擦除APP2内容
   5. 复位更新状态
   6. 跳去APP
   ![bootloader任务执行流程](https://gitee.com/timchanchn/pictures/raw/master/daily/%E5%9B%BA%E4%BB%B6%E5%8D%87%E7%BA%A7/IAP%E6%B5%81%E7%A8%8B%E5%9B%BE.png)
2. 关键步骤
   1. 检查栈顶地址是否合法
   ```c
    if(((*(vu32*)appxaddr)&0x2FFE0000)==0x20000000)
    // (*(vu32*)appxaddr):传入的appxaddr是u32变量
    // 通过类型转换，使其转化成(__IO uint32_t*)型变量(volatile uint32_t*)型，防止编译器优化
    // 进而对该指针进行取址，用户程序的开始位置前4个字节存储着堆栈地址
    // appxaddr~appxaddr+3，堆栈地址必定是指向RAM空间的，而STM32的RAM空间地址是0x20000000,因此通过此判断
    // 确定堆栈地址是否合法
    ```
    2. 设置新的程序跳转地址
    ```c
    jump2app=(iapfun)*(vu32*)(appxaddr+4);  // appxaddr+4:程序的复位函数地址
    ```
    3. 初始化新的堆栈，重新设定堆栈地址
    ```c
    MSR_MSP(*(vu32*)appxaddr);      // 用户代码区的第一个字用于存放栈顶地址
    ```
    4. 跳转去APP
    ```c
    jump2app();                     // 跳转去新的复位函数，进而跳去新APP中
    ```

#### 3. APP1
1. 中断向量表重定向
    ```c
    SCB->VTOR = FLASH_BASE | NES_ADDRESS;           // NEW_ADDRESS是APP相对于FLASH的偏移量，若是其他存储设备，同样操作
    ```
2. 正常功能编写
3. 接收bin文件
4. 更新`更新状态位`，此处定义更新状态位为`更新状态+bin文件大小`，更新状态为最高位。
![APP1流程图](https://gitee.com/timchanchn/pictures/raw/master/daily/%E5%9B%BA%E4%BB%B6%E5%8D%87%E7%BA%A7/APP1%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

> 备注：APP2应该与在升级方面，应该要有一样的功能:接收bin文件后，对其进行CRC校验