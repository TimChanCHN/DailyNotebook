# 文件系统学习
> 文件系统学习是基于知乎文章[一口气搞懂「文件系统」，就靠这 25 张图了](https://zhuanlan.zhihu.com/p/183238194)
## 1. 文件系统的组成
1. 文件系统的基本数据单位是文件，目的是对磁盘上的文件进行组织管理，不同的文件系统其组织方式不同；
2. 在Linux中，`一切皆文件`，普通文件、目录文件、块设备文件、管道文件、socket、字符设备文件等都是交由文件系统管理；
3. 文件系统会为每个文件分配两个数据结构:`索引节点`和`目录项`
   1. `索引节点(inode)`:记录`inode`编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等基本文件信息;是文件的唯一标识，与文件一一对应；索引节点同样会存储于存储介质当中，索引节点同样占用磁盘空间；
   2. `目录项(dentry)`:记录文件名字、`索引节点指针`以及与其他目录项的层级关联关系；多个目录项关联，形成了目录结构；目录项是由内核维护的一个数据结构，不存放于磁盘，只缓存于存储介质中。
   3. 由于索引节点唯一标识一个文件，而目录项记录着多个文件名，因此目录项与索引节点的关系是多对一，如硬链接的试下，就是多个目录项的索引节点指向同一个文件；
4. 磁盘读写的最小单位是`扇区`，大小为`512B`，文件系统把多个扇区组成一个块，Linux的逻辑块大小是`4KB`，即一次性读写8个扇区，提高磁盘读写效率；
5. 索引节点、目录项、文件数据之间的关系:
   1. 索引节点是存储于硬盘中的数据，为了加快文件的访问，通常回把索引节点加载到内存中；
   2. 硬盘格式化时，会分成三个存储区域:
      1. 超级块:存储文件系统详细信息，块个数、块大小、空闲块等；
      2. 索引节点区:存储索引节点；
      3. 数据块区:存储文件或目录数据
   ![索引节点、目录项、文件数据之间的关系](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E3%80%81%E7%9B%AE%E5%BD%95%E9%A1%B9%E3%80%81%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB.png)

### 备注:
1. 目录也是文件，同样需要用索引节点唯一表示，也存储于硬盘中，只不过存储于硬盘中的是子目录或文件而不是文件数据(普通文件);
2. `目录项`和`目录`的区别
   1. `目录项`:内核的一个数据结构，缓存在内存中--内核把读过的目录用目录项这个数据缓存，下次再读到相同目录时直接从内存中读，避免频繁从磁盘中读，影响效率；
   2. `目录`:文件，存储于硬盘中
3. 超级块和索引文件加载到内存的时机:
   1. `超级块`：文件系统挂载时加载到内存;
   2. `索引节点区`:文件被访问时加载到内存。

## 2. 虚拟文件系统(VFS)
1. 虚拟文件系统:针对种类繁多的文件系统，操作系统希望对用户提供一个统一接口，于是在用户层和文件系统层中间引入虚拟文件系统(VFS)；
2. VFS定义了一组所有文件系统都支持的数据结构和标准接口，开发者不需要管文件系统种类，只需要了解改统一接口即可；
3. 文件系统类别:
   1. 磁盘的文件系统:直接把数据存储于磁盘中；
   2. 内存的文件系统:该类文件系统的数据存储于内存中，对该类文件的读写其实就是对内核相关数据的读写；
   3. 网络文件系统:访问其他计算机主机数据的文件系统，如NFS、SMB等
4. 文件系统首先要挂在到某个目录下才可以正常使用
5. Linux文件系统中，用户空间、内核空间各个文件系统以及系统调用之间的关系:
   ![用户空间、内核空间各个文件系统以及系统调用之间的关系](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81%E5%86%85%E6%A0%B8%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB.jpg)

## 3. 文件的使用
1. 文件使用的流程
   1. 使用`open`系统调用打开文件;
   2. 使用`write`写数据，经过一系列操作，数据会写进硬盘中;
   3. 文件使用结束后，使用`close`关闭文件
2. 操作系统会为所有进程维护一个`打开文件表`，该表中的每一相代表`文件描述符`，`文件描述符`是打开文件的标识
3. `打开文件表`维护着打开文件的状态和信息
   1. 文件指针:系统跟踪上次读写位置作为当前文件位置指针，该指针对于打开文件的进程来说是唯一的；
   2. 文件打开计数器:该计数器跟踪着同一个文件的进程打开和关闭数量；当计数器为0时，则删除该条目；操作系统必须重用其打开文件表条目，否则表空间不够用。
   3. 文件磁盘位置:描述文件在磁盘的位置，该信息存储在内存中，当文件操作时则从该信息中获取文件的具体位置；
   4. 访问权限:进程访问文件的模式
4. 用户和操作系统对文件的读写是有差异的，用户习惯以字节的方式读写文件，操作系统则是以数据块读写文件，屏蔽掉这种差异的工作则由文件系统处理
5. 读写文件流程
   1. 读文件:当用户进程从文件读取1个byte数据时，文件系统则需要获取字节所在的数据块，在返回数据块对应用户进程所需的数据部分；
   2. 写文件：当用户进程把1个btye数据写进文件时，文件系统则找到需要写入数据的数据块位置，然后修改数据块对应的部分，再把数据块写入磁盘
6. 文件系统的基本操作是数据块。

## 4. 文件的存储
### 1. 连续空间存储
1. 指文件连续地存储在磁盘中;
   ![连续空间存储示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
2. 使用该方式的前提:需要知道文件起始位置、文件大小;
3. 优点:文件读写效率很高，因为只需一次寻址，
4. 缺点:会容易产生磁盘碎片以及文件大小不易拓展;
   ![连续空间存储方式缺点示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F%E7%BC%BA%E9%99%B7.jpg)

### 2. 非连续空间存储
#### 1. 链表方式
1. 链表方式是离散的，不连续的;
2. 优点:消除磁盘碎片，大大提高磁盘利用率,且文件长度可以动态拓展
3. 链表方式有显式链表和隐式链表
   1. 隐式链表:文件头包含`第一块`和`最后一块`的位置，且每个数据块都留出一个指针空间，用于存放下一个数据块的位置，这样一个数据块连着下一个数据块，从链表头开始顺着指针可以找到所有的数据块，因此存放方式是不连续的。
   - 缺点:
     - 无法直接访问数据块，只能通过指针顺序访问文件;
     - 数据块指针消耗了一定的存储空间;
     - 稳定性差，系统运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致整个文件数据的丢失  
   ![隐式链表示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E5%82%A8--%E9%9A%90%E5%BC%8F%E9%93%BE%E8%A1%A8.jpg)
   2. 显式链表:把用于链接文件各数据块的指针，显式地放在内存地一张链接表中，该表在磁盘中只设置一张，每个表项中存放链接指针，指向下一个数据块号。
   - 优点:
     - 显著提高检索速度
     - 大大减少了访问磁盘次数
   - 缺点:
     - 不适用于大磁盘
       - 如200GB的磁盘和1KB的块，该表需要2亿项，每一相对应于该2亿个磁盘块中的一个块，如果每块需要4个字节，则这张表占用内存为800MB.
   > 显式链表工作方式[该方式也叫文件分配表]:如下例子:
   > 文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。最后以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束
   ![显式链表示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.jpg)

#### 2. 索引方式
1. 链表方式解决了连续分配的磁盘碎片和文件动态拓展的问题，但是不能有效直接访问(需要通过链表间接访问,FAT文件系统除外)，索引方式可以解决该问题。
2. 实现：为每个文件创建一个`索引数据块`，在里面存放着`指向文件数据块的指针列表`，通过指针列表可以直接找到对应的磁盘；此外，文件头需要包含指向`索引数据块`的指针，从而可以令文件头找到`索引数据块`，再通过`索引数据块`里的索引信息找到对应的数据块。
3. 优点:
   - 文件创建、增大、缩小很方便；
   - 不会有碎片问题；
   - 支持顺序读写和随机读写
4. 缺点:
   - 如果文件很小，只需要一块就可以存放的，但还是需要一块用于存储索引数据块，这是索引数据块带来的额外开销
  ![索引方式示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
5. 链式索引块:用于处理大文件的存储，要是一个文件大到一个存储索引块都无法完全存储，可以使用该方式，当一个索引信息使用完之后，可以通过指针的方式找到下一个存储索引块，但是该方式同样存在如果指针损坏导致数据损坏问题
   ![链式索引方式示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
6. 多机索引块:使用索引+索引的方式，第一个存储索引块用于存储多个索引数据块，实现对多个索引块的管理，从而可以找到大文件
   ![多级索引方式示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
   ![顺序分配、链表分配、索引分配方式比较](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E6%89%80%E6%9C%89%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png)

### 3. UNIX文件索引实现方式
1. UNIX根据文件大小，存放方式有所变化:
   - 如果存储文件所需数据块小于10，使用直接查找方式；
   - 如果存储文件所需数据块超过10，使用一级间接索引方式；
   - 如果前面两种方式都不够存放大文件，则采用二级间接索引方式；
   - 如果二级间接索引方式还不够存放大文件，则采用三级间接索引方式
![Unix文件系统示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/unix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)


## 5. 空闲空间管理
> 当需要使用磁盘来保存文件时，使用空闲管理，为了更高效地找到可以使用的空闲块用于存储数据。
### 1. 空闲表法
1. 该方法是为所有的空闲空间建立一张表，表内容包括空闲区的第一个块号以及该空闲区的块个数，该方式是连续分配的
   ![空闲空间管理--空闲表法示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
2. 当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个空闲的区域为止；当用户撤销一个文件时，系统回收该文件空间，同时也会顺序扫描空闲表，寻找一个空闲表条目把该空闲空间填到表中；
3. 优劣：
   1. 该方法仅当又少量的空闲区时才有较好的效果
   2. 如果存储空间有着大量的小空闲区，则空闲表变得很大，导致查询效率低
   3. 该分配技术适用于建立连续文件

### 2. 空闲链表法
1. 空闲链表法:每个空闲块中的指针指向下一个空闲块；
2. 当创建文件需要一块或几块时，则从链表头一次取下一块或者几块；反之，当回收空间时，把这些空闲块一次接到链头上；
3. 优劣:
   1. 只需要在主存中保存一个指针，令它指向一个空闲块，操作简单；
   2. 不能随机访问；
   3. 工作效率低，链表移动时需要很多I/O操作
   4. 数据块的指针消耗了一定的存储空间
   ![空闲空间管理--空闲链表法示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

> 空闲表法和空闲链表法都不适合用于大型文件系统，否则空闲表和空闲链表消耗大。

### 3. 位图法
1. 位图:利用二进制的一位表示磁盘的一个盘块的使用情况，磁盘上所有的盘块都会有一个二进制位与之对应
2. 当bit为0时，表示对应盘块空闲；当bit为1时，表示对应盘块已经分配
   ```
   1111110011111110001110110111111100111 ...
   ```
3. Linux文件系统就是使用位图的方式管理空闲空间，除了数据空闲块的管理，inode空闲块的管理也是使用位图法管理。

## 6. 文件系统结构
1. 例子，计算一个数据块位图(数据块位图也是存储在磁盘块中)可以管理的磁盘大小:
   ```
   一个块大小:4K,因此如果一个数据块内容全是位图的内容，因此其可以管理的空闲块个数:4*1024*8=2^15个空闲块，因此能管理的最大空间:2^15*4*1024=2^17byte=128M。
   ```
2. `块组`:一个块的位图+一系列的块。在Linux文件系统中，使用N个块组对内存空间进行管理；
3. Linux Ext2文件系统的结构和块组内容
   - 引导块:系统启动时的启用引导，接在后面的就是连续的块组
   - 块组内容
     - 超级块:包含文件系统的重要信息--inode总个数、块总个数、每个块的inode个数、块组的块个数等等；
     - 块组描述符组:包含文件系统各个块组的状态--如块组中空闲块和inode数目等，每个块组都包含了文件系统中`所有块组的组描述符信息`
     - 数据位图和inode位图:表示对应的数据块/inode时空闲还是被使用中
     - inode列表:包含块组内所有的inode，inode用于保存文件系统中与各个文件和目录相关联的所有元数据
     - 数据块:包含文件的有用数据
   ![Linux Ext2文件系统的结构和块组内容](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%92%E5%B8%83%E6%96%B9%E5%BC%8F.jpg)  
4. 块组中的重复信息(超级块和块组描述符表)该设定的原因:
   - 系统崩溃破坏了超级块或块描述符，有关文件系统结构和内容的所有信息都会丢失，有冗余副本则可以恢复该信息；
   - 通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，提高文件系统性能

## 7. 目录的存储
> 在Linux中，目录也是以文件的形式存储。  
> 普通文件的块里面存储的是文件数据，而目录文件的块里面存储的是目录里面的文件信息。
### 1. 列表
1. 列表:一项一项地将目录下地文件信息(文件名、文件inode、文件类型等列在表里);
2. 列表中地每一项就代表该目录下地文件的文件名和对应的inode，通过inode，可以找到真正的文件;
3. 缺点:
   - 如果一个目录下有超级多文件，通过该目录查找文件，一项一项查找，效率会很低;

### 2. 哈希表
1. 把保存的目录格式改成哈希表，对文件名进行哈希计算并把哈希值保存，当要查找一个目录下面的文件名，通过名称取哈希值，如果哈希匹配成功，则可以在对应的目录下找到文件;
2. 优劣:
   - 查找迅速，插入和删除简单
   - 需要预备措施避免哈希冲突(同名文件的查找)
3. 目录查询是通过磁盘上的反复搜索完成，需要不断地进行I/O操作，开销大，为了减少I/O操作，把当前文件使用的目录缓存在内存，以后要使用该文件只要在内存中操作，从而降低磁盘操作次数，提高文件系统访问速度。

![目录存储方式示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

## 8. 软链接和硬链接
> 给某个文件取别名，可以使用软链接/硬链接。
### 1. 硬链接
1. 多个目录项中的`索引节点`指向同个文件，即同个inode
2. 备注:inode不能跨文件系统使用，因此硬链接不可用于跨文件系统
3. 在文件系统中，要想彻底删除拥有`硬链接`的文件，只有删除文件的所有硬链接以及源文件时，才能彻底删除该文件。
![硬链接示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

### 2. 软链接
1. 软链接相当于重新创建文件，该文件有独立的inode
2. 软链接的inode指向的内容是源文件的路径，故访问软链接时，相当于访问了另外一个文件，所以软链接时可以跨文件系统使用，甚至目标文件被删除了，链接文件还在，只是指向的文件找不到而已。
![软链接示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

## 9. 文件IO
### 1. 缓冲IO和非缓冲IO
1. 文件操作的标准库可以实现数据的缓存，根据`是否利用标准库缓存`，可以把文件I/O分为`缓冲I/O`和`非缓冲I/O`
   1. `缓冲I/O`:利用标准库的缓存实现文件的加速访问，而标准库通过系统调用访问文件
   2. `非缓冲I/O`:直接通过系统调用访问文件，不经过标准库缓存。
2. `缓冲`是指标准库内部实现的缓冲
3. 例子:程序遇到换行时才真正输出，而换行前内容则被标准库缓存起来，目的是为了减少系统调用次数，而系统调用是由CPU上下文切换的开销的

### 2. 直接与非直接IO
> 磁盘I/O是很慢的，Linux内核为了减少磁盘I/O次数，在系统调用后，会把用户数据拷贝到内核中缓存起来(内核缓存空间也是`页缓存`)，只有缓存满足某些条件时，才发起磁盘I/O请求。
1. 直接I/O:不会发生内核缓存和用户程序之间数据复制，而实直接经过文件系统访问磁盘;
2. 非直接I/O:读操作时，数据从内核缓冲中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。
3. 使用文件操作类系统调用函数时，指定了`O_DIRECT`标志，表示使用直接I/O，否则默认使用非直接I/O
4. Q：采用非直接I/O进行写数据操作，内核在什么时候才会把缓存数据写入磁盘？  
   - 调用`write`后，发现内核缓存的数据太多时，内核会把数据写到磁盘上；
   - 用户主动调用`sync`，内核缓存会刷到磁盘上；
   - 当内存十分紧张时，无法再分配页面时，内核缓存会刷到磁盘上；
   - 内核缓存的数据的缓存时间超过某个时间，内核缓存会刷到磁盘上。

### 3. 阻塞与非阻塞IO和同步与异步IO
1. 阻塞I/O:当用户执行`read`时，线程会被阻塞，直到内核数据准备好，并把数据从内核缓存区拷贝到应用程序的缓冲区中，当拷贝完成，read才会返回。
   - 阻塞等待的是`内核数据准备好`和`数据从内核态拷贝到用户态`这两个过程
   ![阻塞I/O--读流程示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E9%98%BB%E5%A1%9EIO%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
2. 非阻塞I/O:当用户执行`read`时，若数据未准备好会立即返回，线程可以继续往下执行；此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，`read`调用才可以获得结果
   - read的最后一次调用，是数据获取过程，是一个同步的过程，是需要等到的过程。
   ![非阻塞I/O--读流程示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
3. I/O多路复用:通过I/O事件分发，当内核数据准备好是，再次以事件通知应用程序进行操作，接口有`select`,`poll`
   ![select多路复用过程](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E5%A4%8D%E7%94%A8IO%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
> 备注：阻塞I/O， 非阻塞I/O, I/O多路复用都是同步的过程，因为在read调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，即都是需要等到数据准备好才read才会有返回。如果内核实现的拷贝效率不高，read调用就会在这个同步过程中等待较长的事件。
4. 异步I/O:`内核数据准备好`和`数据从内核态拷贝到用户态`这两个过程不用等待。当发起异步读`aio_read`时，内核自动将数据从内核空间拷贝到应用程序空间，由于该拷贝是异步的，应用程序不需要自动发起拷贝动作
   ![aio_read异步读流程示意图](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E5%BC%82%E6%AD%A5IO.jpg)

![几种I/O模型总结](https://gitee.com/timchanchn/pictures/raw/master/daily/filesystem/%E5%87%A0%E7%A7%8DIO%E6%A8%A1%E5%9E%8B.jpg)



## 问题:
1. 文件系统是如何把程序要写的内容写进硬件存储介质中？
   - 首先应用程序使用`open`函数，系统调用把文件的路径通过VFS传送给文件系统；
   - 文件系统根据所在路径的目录块，找到目标文件对应的数据块；
   - 其次应用程序使用`write`函数，系统调用把用户空间的缓存通过VFS送给内核空间的缓存空间中
   - 文件系统再根据之前所找到文件对应的数据块的具体硬件存储介质地址，通过最底层的存储介质写接口，把内核缓存的内容写进硬件介质中。


