# 1 LwIP学习
## 1. 网络协议简介
1. TCP/IP是一个协议族，包含众多协议族，各个层的协议，都算是该协议族里面的一个协议；
2. TCP/IP是一个十分复杂的协议族，对于嵌入式产品并不适用，因此需要LwIP这种轻量式TCP/IP协议，来满足嵌入式产品的使用要求；
3. 网络协议分层模型：
   1. 物理层：规定了传输信号所需要的物理电平、介质特性
   2. 链路层：规定了数据帧能被网卡接收的条件
      1. 常用的方式是利用网卡的MAC地址，发送方把与发送的数据帧首部加上接收方网卡的MAC地址信息，接收方只有监听到属于自己的MAC地址信息后，才会处理该数据
   3. 网络层：实现数据包在主机之间的传递
   4. 传输层：区分数据包属于哪一个应用程序，实现数据包端到端传递
      1. 传输过程中可能会出现丢包、乱序、重复等现象，网络层并没有解决这些问题，而传输层则提供了应对这些错误的机制
   5. 应用层：决定如何应用和处理这些数据，应用层种类繁多，就是因为互联网中传输的数据种类多、差异大、应用场景多样
   ![TCP/IP协议分层]()
4. 协议层报文间的封装与拆封
   ![TCP/IP协议栈各层的报文封装与拆封]()

## 2. LwIP
### 1.简介
1. LwIP的三种编程接口
   1. RAW API
      1. 内核回调型API
      2. 当接收到数据时，会触发callback函数，通知用户收到数据
      3. 优点：
         1. 可以在无操作系统环境中使用
         2. 在操作系统环境中使用，对比另外两种API，RAW API可以提高应用程序效率、节省内存开销
      4. 缺点：
         1. 利用回调实现业务逻辑比较麻烦，代码可读性差
         2. 在操作系统环境中，应用程序代码与内核代码处于同一线程，虽然可以节省任务间通信、切换任务的开销，但是应用程序的执行会制约内核程序的执行，不同的应用程序之间也会互相制约；应用程序执行时，内核程序不可能运行，这会影响网络数据包的处理效率，有可能会导致丢包现象。
   2. NETCONN API
      1. 使用在操作环境中，该方式是基于操作系统的IPC机制(信号量和邮箱机制)实现的
      2. 设计思想是把LwIP的内核代码和网络应用程序分离成独立线程，大大提高系统对网络数据包的处理效率
         1. 内核线程只做数据包的TCP/IP封装和拆封
         2. 应用层线程对数据进行应用层处理
      3. 通过数据结构netbuf来对网络数据进行读写
      4. 优点:
         1. 简化编程工作，但是内核程序和应用层程序之间的数据包传递需要依靠操作系统的信号量和邮箱机制完成，需要消耗更多的时间和内存，并且还需要加上任务切换的时间开销，效率较低
         2. 和socket相比，避免了内核程序和应用程序的数据拷贝，提高数据递交效率，但是易用性不如socket，需要用户对LwIP内核所使用的数据结构有一定的了解。

   3. SOCKET API
      1. 对网络连接进行了高级的抽象，使得用户可以向操作文件一样操作网络连接；
      2. 不同系统的socket接口不一样，windows的是winsock，unix/linux和LwIP使用的是BSD Socket,但是LwIP不能实现全部的BSD Socket
      3. 与NETCONN API相比，Socket API具有更好的易用性，使得程序可读性好、便于维护、移植性高。
      4. Socket API在内核程序和应用程序之间存在数据拷贝，这会降低数据递交效率
      5. Socket API是基于NETCONN API实现的，因此效率和NETCONN API相比效率会有所降低。
2. 可移植性强
3. 免费、开源
4. 发展悠久，稳定
5. 缺点:由于是专门用于嵌入式系统，因此并没有完整地实现TCP/IP协议

## 3.开发平台介绍
1. 以太网简介
   1. 以太网是指遵守IEEE 802.3标准组成的局域网，该标准规定的主要是位于参考模型的物理层(PHY)和数据链路层中的介质访问子层(MAC)
   2. 标志是用水晶头网线连接
   3. 其他标准：
      1. WIFI : IEEE 802.11
      2. 蓝牙: IEEE 802.15
      3. ZigBee: 802.15.4

2. PHY层
   1. 在物理层，IEEE 802.3标准规定了以太网使用的传输介质、传输速度、数据编码方式、冲突检测机制
   2. 物理层一般是由一个PHY芯片实现其功能，如LAN8702
   3. 传输介质:同轴电缆、双绞线、光纤
   4. 编码:为了让接收方在没有外部时钟参考的情况下也能确定每一位的起始、结束、中间位置，传输信号时不采用二进制编码，在10BASE-T传输方式采用曼彻斯特编码，在100BASE-T中采用4B/5B编码
3. CSMA/CD冲突检测
   1. 当多个节点连接到同一条网络总线上，存在信道竞争问题，因而每个连接到以太网上的节点都必须具有冲突检测功能；
   2. 以太网具备CSMA/CD冲突检测机制，如果多个节点同时利用同一条总线发送数据，则会产生冲突，总线上的节点可以通过接收到的信号与原始发送的信号比较检测是否存在冲突，若存在冲突则停止发送数据，随机等待一段时间再重传
4. MAC子层
   1. 功能：
      1. 属于数据链路层的下半部分，负责与物理层进行数据交接，如是否可以发送数据，发送的数据是否正确，对数据流进行控制等。
      2. 它自动对来自上层的数据包加上一些控制信号，交给物理层；接收方得到正常数据时，自动去除MAC控制信号，把该数据包交给上层；
   2. MAC数据包:IEEE对以太网上传输的数据包格式也进行了统一规定，即MAC数据包，如图:
   ![MAC数据包格式]()
   
5. STM32的ETH外设
   1. STM32F4xx系列控制器内部集成了一个以太网外设，实际是通过一个DMA控制器进行介质访问控制(MAC),功能是实现MAC层任务
   2. ETH内部自带专用的DMA用于MAC，同时还支持两个工业标准接口介质独立接口(MII)和简化介质独立接口(RMII)用于和外部PHY芯片连接
   3. ETH有专用的DMA控制器，通过AHB主从接口与内核和存储器连接
      1. AHB主接口用于控制数据传输，AHB从接口用于访问“控制与状态寄存器”(CSR)空间
      2. 发送数据:先将数据由存储器以DMA传输到发送TX FIFO进行缓存，然后又MAC内核发送
      3. 接收数据:RX FIFO先接收以太网数据阵，再由DMA传输到存储器
      4. ![ETH系统功能框图]()
6. MII/RMII接口
   1. 用于连接MAC控制器和PHY芯片，提供数据传输路径
7. PHY:LAN8720A
   1. 简介:体积小、功耗低、10/100Mbps，24pin，仅支持RMII接口
   2. ![由LAN8720A组成的网络系统结构]()

## 4. LwIP网络接口管理
1. netif结构体
   1. LwIP使用结构体netif来描述一个网卡
      1. 由于网卡是直接与硬件打交道，不同的硬件操作不同，因此提供结构体netif来对各个硬件进行操作
      2. 硬件的操作主要是网卡初始化、数据收发，各个硬件操作一般不一样，需要用户实现相应操作，并使用结构体netif进行管理
      3. 网卡的硬件实现是在`ethernetif.c`中实现，当LwIP内核需要对网卡进行数据收发时，就会调用该结构体netif对象
      4. 若有多个网卡，LwIP会把所有的netif结构体构建成一个链表去管理
    2. netif结构体内容
       1. netif*:网卡链表指针
       2. IP地址、网关、掩码信息
       3. 函数指针:内核发送数据包(output), 网卡接收数据包(input)
       4. MAC地址长度、链路层硬件地址等等
2. netif的使用
   1. 先定义一个netif结构体变量
   2. 对改变量进行初始化：IP地址、网关、掩码等信息初始化，如果不使用DHCP的话，这些信息就会手动设置
   3. 调用函数net_add，进行网卡挂载(该函数在`TCPIP_Init`中被调用)
   4. 在调用函数net_add后会自动触发netif_init_fn，从而对网卡进行初始化
3. netif相关函数
   1. `low_level_init()`:网卡复位以及参数初始化
   2. `low_level_output()`:网卡数据发送函数
   3. `low_level_input()`:网卡数据接收函数
4. ethernetif.c基本介绍
   1. ethernetif结构体
      1. 描述底层硬件设备的一些私有信息:MAC地址
      2. LwIP用于响应ARP查询的核心数据
      3. 可以添加网卡的其他描述信息
   2. ethernetif_init
      1. LwIP中默认的网卡初始化函数(网卡的具体初始化操作还是需要low_level_init())
   3. low_level_init
      1. 初始化MAC地址、长度，设置最大传输包大小，设置网卡属性，支持广播、多播、ARP功能
      2. 若是操作系统，还需要建立接收、发送数据的任务
      3. 具体的网卡初始化函数`Bsp_Eth_Init()`,不同的网卡该函数不一样，由用户实现

## 5. LwIP内存管理
### 1. 常见内存分配策略
1. 固定大小内存块
   1. 原理:在内存初始化的时候，系统会将所有的内存区域划分为N块固定大小的内存，然后将这些内存块通过单链表的方式链接起来。用户在申请内存块的时候直接从表头取出内存块进行分配，而释放内存块的时候也是同理。
   2. 该分配方法也叫动态内存池
   3. 特点：分配内存的时间是固定的且高效，并且不会产生内存碎片；但缺点同样明显，只能申请固定大小内存，如果内存块无法满足用户需求，则无法申请成功，而如果将内存块变大，则不利于极小内存的使用情况。
   4. 由于LwIP中有很多固定的数据结构空间，采用这种内存分配方法可以提高效率
   5. ![动态内存池示意图]()
2. 利用内存堆进行动态分配，即可变长度内存块
   1. 原理：内存初始化时，先分配一块大内存，用户申请内存时，就会从这块大内存中获取相应大小内存，释放时也同理。
   2. LwIP使用的内存分配算法:申请内存时，先从大内存中查找比请求内存更大的内存块，从中割出合适的块，并把剩余部分返回到内存堆中。而释放内存时则是相反过程，但分配器会查看相邻内存块是否空闲，是则合并。
   3. 优点:内存浪费小、简单、适合小内存管理
   4. 缺点:如果内存申请与释放频繁，会造成严重的内存碎片，若碎片情况严重，会导致内存分配不成功而导致系统崩溃。
   > 内存碎片:并不是系统没有可用内存，而是内存块被分割成很多不连续的小内存块，当用户申请一块更大的内存块时，系统无法提供，导致申请失败。
3. C库函数的内存管理

### 2.动态内存池
1. 内存池申请大小必须是指定固定大小字节的值(如4、8、16等)，系统将所有的可用区域以固定大小的字节单位进行划分，然后使用单链表将所有空闲内存块连接起来；
2. LwIP使用的是动态内存分配策略，但是用动态内存池的目的是协议栈有大量的协议首部，协议首部内存是固定的，所以此处使用固定内存可以提高效率；
3. 内存池预处理:
   1. 内核在初始化内存池的时候，根据用户配置的宏定义进行初始化，如用户定义了LWIP_UDP时，编译器会把与UDP协议控制块相关的数据结构编译进去内核，而在初始化时，UDP协议控制块需要POOL资源就会被初始化，数量由MEMP_NUM_UDP_PCB决定
4. 内存池初始化
   1. LwIP协议栈初始化的时候，`memp_init()`会对内存池进行初始化，真正内存初始化由函数`memp_init_pool()`开始
   2. 初始化函数的作用是根据每种POOL的`memp_desc`描述进行初始化，每种类型的POOL中将空闲内存块链接成单链表，并用memset对其清零
   3. ![初始化示意图]()
5. 内存分配
   1. 使用接口memp_malloc函数进行申请内存块，通过传入POOL类型，系统从对应的内存池中取出一个空闲块递给用户，同时空闲链表指针指向下一个空闲块
   2. 系统通过`memp_pools`数组来寄存内存池信息，如其中的tab成员变量就是空闲块信息
6. 内存释放
   1. 使用释放内存接口，传入POOL类型以及内存块地址地址，就可以把使用完毕的内存添加到内存池中
   2. 把空闲块加入到 `memp_pools`数组相应的位置中

### 3. 动态内存堆
1. 动态内存堆分为两种:C标准库自带的内存管理策略、LwIP自身实现的内存堆管理策略，通过宏`MEM_LIBC_MALLOC`进行管理
2. 内存堆结构
   1. 链表指针(prev,next)指的是目的地址的偏移量，及地址是内存堆的起始地址
   2. used:标志该内存是否被使用
   3. 申请的内存最小为12字节
   4. 登等
3. 内存堆初始化
   1. 设置内存堆起始地址
   2. 初始化空闲列表
   3. 根据用户配置的宏定义进行相关初始化，配置不同则实现也不同
   4. 初始化起始空闲块，标记未使用；初始化终止空闲块，标记为使用
   ![内存堆初始化完胜示意图]()
4. 内存分配
   1. 对内存进行对其操作、判断是否小于最小内存等基本判断
   2. 遍历空闲内存链表，知道找到第一个合适用户需求的内存块大小
   3. 获得内存块起始地址
   4. 判断内存块是否满足需求，若内存块过大，则对其进行分割，将指定大小内存送给用户，剩余部分记录成一块新的空闲块，并将其插入空闲内存块链表中
   5. 标记分出去的内存块为已使用
   6. 若分出去的内存块是lfree指向的内存块，则找到第一个低地址的内存块，并将lfree指向它
   7. 返回内存块起始地址
   ![内存块完成示意图]()
5. 内存释放
   1. 根据用户释放的内存块地址，通过偏移mem结构体大小得到正确的内存块起始地址
   2. 根据mem中保存的内存块信息进行释放、合并操作，并将used清零
   3. LwIP为了防止内存碎片，将内存中相邻的两个空闲内存块进行合并

> LwIP在内存堆和内存池的实现上设计得非常灵活，内存池可由内存堆实现，内存堆可由内存池实现。通过宏`MEM_USE_POOLS`或` MEMP_MEM_MALLOC`，二者只能选择其一
> `MEM_LIBC_MALLOC`:该宏表示是否使用C标准库自带的内存分配策略

## 6. 网络数据包
### 1. TCP/IP协议分层思想
1. 标准的TCP/IP协议栈中，各层之间都是一个独立的模块，每一层只负责完成该层的处理，不会越界到其他层次去读写数据。
2. 标准TCP/IP协议栈中，各层使用的内存空间是不一样的，各层的数据处理使用的是各自对应的内存，并且各层之间传递数据少不了数据的拷贝。
3. 针对第2点问题，嵌入式设备中稀缺的内存容量以及处理能力有限的处理器，处理标准的TCP/IP协议栈会占用大量的资源
4. LwIP则是一个轻量的TCP/IP协议栈，它模糊了分层管理，假定用户是十分清楚协议栈的处理流程，因此各层之间少了数据拷贝等操作，在节省内存资源的同事，也让嵌入式可以实现TCP/IP功能。

### 2. LwIP线程模型
1. LwIP的设计是让协议栈内核与操作系统相互隔离，协议栈仅仅作为操作系统的一个独立线程存在，用户程序能驻留在协议栈内部，协议栈通过回调函数实现用户与协议栈之间的数据交互
2. 或者用户程序单独实现一个线程，与协议栈使用系统的信号量和邮箱等IPC通信机制联系起来，进行数据交互
3. 优点:能在任意操作系统中移植
4. 缺点:受到操作系统影响，因为操作系统调度是需要时间的，协议栈响应的实时性会有一定的影响，因此建议设置LwIP线程优先级为最高优先级。

### 3. pbuf结构体说明与pbuf类型
1. pbuf是一个描述协议栈中数据包的数据结构
2. LwIP在pbuf.c和pbuf.h中实现协议栈数据包管理的所有函数以及数据结构
3. pbuf作用:
   1. *next:pbuf指针，当数据包很大时，需要使用多个pbuf结构体来描述，此时则使用该指针把所有节点链接成一个链表，
   2. payload:指向该pbuf管理的数据区域起始地址
   3. tot_len:当前pbuf及其后续pbuf所有数据的长度
   4. len:当前pbuf中有效的数据长度
   5. type_internal:pbuf类型
   6. ref:pbuf被引用次数
   7. if_idx:用于记录传入的数据包中输入netif索引，也是netif中num字段
   8. layer:协议栈头部空间
4. pbuf类型
   1. PBUF_RAM
      1. 通过内存堆分配而来，该类型pbuf在协议栈中使用得最多
      2. 该pbuf内存块包含数据空间以及pbuf数据结构区域，在连续得RAM内存空间中
      3. 该类pbuf也算上了协议首部空间
      4. ![PBUF_RAM类型pbuf示意图]()
   2. PBUF_POOL
      1. 该类pbuf和PBUF_RAM类似，只是他的空间通过内存池分配
      2. 该类pbuf可以在极短的时间内分配的到
      3. 网卡接收数据的时候，LwIP一般就是使用这种类型的pbuf存储接收到的数据
      4. 在系统进行内存池初始化的时候，还会初始化两个与pbuf相关的内存池:MEMP_PBUF、MEMP_PBUF_POOL
         1. MEMP_PBUF:专门用于存放pbuf数据结构的内存池，主要是用于PBUF_ROM/PBUF_REF类型pbuf
         2. MEMP_PBUF_POOL:包含pbuf结构与数据区域，即PBUF_POOL
   3. PBUF_ROM/PBUF_REF
      1. 该两种类型的pbuf基本一样，在内存池中申请的pbuf只包含pbuf结构体，不包含数据区域
      2. PBUF_ROM类型的pbuf数据区域存储在ROM中，是一段静态区域
      3. PBUF_REF类型的pbuf数据区域存储在RAM中，是一段动态区域
      ![PBUF_ROM/PBUF_RAM类型pbuf]()
> 备注: 一个数据包可能会由多种pbuf描述，但是无论LwIP怎么对数据包进行描述，对数据包的处理都是恒定不变的。
![不同类型pbuf组成的pbuf链表]()

### 4. pbuf接口函数
1. `pbuf_alloc`
   1. 作用:在网卡接收数据时，申请数据包并将网卡数据填入数据包中；发送数据包时，把即将发送的数据装入pbuf中的数据区域，同时相关协议的首部信息也会被填入pbuf中的layer区域中
2. `pbuf_free`
   1. 当内核处理完数据后就要将这些资源进行回收，否则会造成内存泄漏；
   2. 释放数据包时，需要确认pbuf中的ref是否为0
3. `pbuf_realloc`
   1. 在相应的pbuf链表尾部释放一定空间，将数据包pbuf中的数据长度减少为某个长度值。
4. `pbuf_header`
   1. 用于调整pbuf的payload指针位置，目的是给不同的协议头部，有对应的调整方向
5. `pbuf_take`
   1. 向pbuf数据区域拷贝数据

### 5.在网卡中使用pbuf
1. `low_level_output`
   1. 网卡发送数据函数
   2. 应用层通过网卡发送数据过程:
      1. 将数据传入LwIP内核中
      2. 上层将要发送的数据层层封装，并存储到pbuf数据包中
      3. 若数据太多则需要多个pbuf把当前数据包存放
      4. 发送数据时，需要把一个数据包的数据全部发送，同一个数据包的所有数据必须放在同一个以太网帧中发送

2. `low_level_input`
   1. 从网卡中接收一个数据包，并将数据包封装在pbuf中递交给上层

3. `ethernetif_input`
   1. 上述函数只是完成网卡驱动接收数据，而把pbuf数据递交给上层，则需要使用该函数



